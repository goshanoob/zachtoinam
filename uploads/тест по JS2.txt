Если потребуется каждый элемент массива числовых элементов возвести в квадрат, то наиболее коротким решением будет применение:
*метода map()
~метода reduce()
~цикла for()
~цикла while()

%Охарактеризуйте метод map():
*применяется к массивам
~применяется к строкам
*возвращает новый массив
~изменяет исходный массив
~возвращает новую строку
~изменяет исходную строку

%Охарактеризуйте метод filter():
*применяется к массивам
~применяется к строкам
*возвращает новый массив
~изменяет исходный массив
~возвращает новую строку
~изменяет исходную строку

%Охарактеризуйте метод reduce():
*применяется к массивам
~применяется к строкам
~всегда возвращает новый массив
~изменяет исходный массив
*возвращает новое значение
~изменяет исходное значение

%Охарактеризуйте метод slice():
*применяется к массивам
~применяется к строкам
*возвращает новый массив
~изменяет исходный массив
~возвращает новую строку
~изменяет исходную строку
~возвращает число

%Охарактеризуйте методы split() и join():
~Метод split() применяется к массиву и возвращает новый массив
~Метод join() применяется к массиву и возвращает новый массив
~Метод split() применяется к строке и возвращает новую строку
~Метод join() применяется к строке и возвращает новую строку
~Метод split() применяется к массиву и возвращает новую строку
*Метод join() применяется к массиву и возвращает новую строку
*Метод split() применяется к строке и возвращает новый массив
~Метод join() применяется к строке и возвращает новый массив


%Выберите варианты полного копирования двумерного массива по значениям:<br>
<code>let mas1 = [ [1,2,3], [4,5,6], [7,8,9] ], mas2 = [];</code>
*<pre><code>
for(let i = 0; i < mas1.length; i++){ 
	mas2[i] = []; 
	for(let j = 0; j < mas1[0].length; j++) {
		mas2[i][j] = mas1[i][j];
	}
}
</code></pre>

~<code>mas2 = mas1;</code>

~<code>mas1 = mas2;</code>

*<pre><code>
for(let item of mas1){
	mas2.push([...item]);
} 
</code></pre>

~<code>mas2 = [...mas1];</code>

~<code>mas2 = mas1.slice();</code>

~<code>mas2 = mas1.flat();</code>

~Ни один из вариантов


%Выберите варианты копирования одномерного массива по значениям:<br>
<code>let mas1 = [1,2,3,4,5,6,7,8,9], mas2 = [];</code>

~<pre><code>
for(let i = 0; i < mas1.length; i++){ 
	mas2[i] = []; 
	for(let j = 0; j < mas1[0].length; j++) {
		mas2[i][j] = mas1[i][j];
	}
}
</code></pre>

~<code>mas2 = mas1;</code>

~<code>mas1 = mas2;</code>

~<pre><code>
for(let item of mas1){
	mas2.push([...item]);
} 
</code></pre>

*<code>mas2 = [...mas1];</code>

*<code>mas2 = mas1.slice();</code>

*<code>mas2 = mas1.flat();</code>

~Ни один из вариантов


%Выберите варианты копирования одномерного массива по ссылке:<br>
<code>let mas1 = [1,2,3,4,5,6,7,8,9], mas2 = [];</code>
~<pre><code>
for(let i = 0; i < mas1.length; i++){ 
	mas2[i] = mas1[i];
}
</code></pre>

*<code>mas2 = mas1;</code>

~<pre><code>
for(let item of mas1){
	mas2.push([...item]);
} 
</code></pre>

~<code>mas2 = [...mas1];</code>

~<code>mas2 = mas1.slice();</code>

~<code>mas2 = mas1.flat();</code>

~Ни один из вариантов



%Выберите варианты полного или частичного копирования двумерного массива <code>mas1</code> по ссылке:<br>
<code>let mas1 = [[1,2,3], [4,5,6], [7,8,9]], mas2 = [];</code>

~<pre><code>
for(let i = 0; i < mas1.length; i++){ 
	mas2[i] = []; 
	for(let j = 0; j < mas1[0].length; j++) {
		mas2[i][j] = mas1[i][j];
		}
	}
</code></pre>

*<code>mas2 = mas1;</code>

~<pre><code>
for(let item of mas1){
	mas2.push([...item]);
} 
</code></pre>

*<code>mas2 = [...mas1];</code>

*<code>mas2 = mas1.slice();</code>

~<code>mas2 = mas1.flat();</code>

~Ни один из вариантов


%Простой вызов метода sort() отсортирует массив чисел:
~по возрастанию 
~по убыванию
*по алфавиту
~в обратном порядке


%Выберите методы, с помощью которых можно добавить элементы в массив:

~shift()
*unshift()
*splice()
~slice()
*concat()
~pop()



%Какой из способов объявления функции позволяет вызвать ее раньше самого объявления в коде?

*Function Declaration
~Function Expression
~Function Initialization
~Нет такого способа. Сначала объявляем - потом вызываем.
~Deferred Initialization


%Чему равно значение переменной a после выполнения кода?
<pre><code>
let a = 5;
function test(a){
	return a + 1;
}
a = test(10);
</code></pre>

~5
~6
~10
*11
~<code>f(){a + 1}</code>
~Ошибка выполнения



%Чему равно значение переменной <code>a</code> после выполнения кода?
<pre><code>
let a = 5;
function test(){
	return a + 1;
}
a = test(10);
</code></pre>

~5
*6
~10
~11
~<code>f(){a + 1}</code>
~Ошибка выполнения


%Выберите верные утверждения о следующем коде:
<pre><code>
function test(a){
	return function(b = 1){
		return a + b;
	}
}
let result1 = test(5);
let result2 = test(15);
let a = result1(15);
let b = result2(5);
let c = result2();
</code></pre>

*Это пример замыкания
~Переменные a, b и c равны после выполнения кода
~c > a && c > b
~a < c || b < c
~a < c || a < b
*Переменная <code>result1</code> содержит код анонимной функции
~Возникает ошибка выполнения


%Что такое замыкание?
~Это сложно
*Функция, имеющая доступ к переменным, объявленным во внешнем по отношению к ней окружении
~Переменная, которая, получив значение null, не была очищена сборщиком мусора
~Массив, содержащий несколько функций для "конвеерного" преобразования данных
~То же, что и цепочка вызовов методов


%Будет ли значение переменной count удалено из оперативной памяти после выполнения кода?
<pre><code>
function test(){
	let count = 10;
	return function(a){
		return a + count;
	}
}
let a = test();
let b = a(3) + test()(4);
</code></pre>

~Да, так как возникнет ошибка выполнения
*Нет, так как переменная count замкнута внутри функции test()
~Да, так как функция test() завершила выполнение
~Нет, так как фукнция test() не смогла полностью выполниться
~Да, так как произошло размыкание из-за вызова return


%Что содержит переменная <code>result</code>?
<pre><code>
function test(){
	let count = 10;
	return function(a){
		return a + count;
	}
}
let result = test(4);
</code></pre>

*Код анонимной функции 
~Число 14
~Число 4
~Число 10
~NaN
~Null
~undefined


%Сколько аргументов можно передать в функцию?

*Произвольное количество
~Не больше количества параметров функции
~Не меньше количества параметров
~Ровно столько, сколько объявлено параметров функции


%Есть ли разница между аргументами и параметрами функции?

*Да, аргументы передаются при вызове функции и накладываются на параметры
~Да, аргументы объявляются в заголовке функции и накладываются на параметры
~Да, аргументы объявляются в заголовке функции, а параметры накладываются на них при вызове
~Нет, это синонимы
~В JavaScript нет термина "параметр" функции


%Что выведется на консоль?
<pre><code>
let a = 10;
const b = function(){
	let a = 0;
}
b();
console.log(a);
</code></pre>

*10
~0
~undefined
~NaN
~Null
~'a'
~Ошибка


%Что выведется на консоль?
<pre><code>
let a = 10;
const b = function(){
	a = 0;
}
b();
console.log(a);
</code></pre>

~10
*0
~undefined
~NaN
~Null
~'a'
~Ошибка


%Что выведется на консоль?
<pre><code>
if (true) {
    var a = 3;
    let b = 5;
}
console.log(a + b);
</code></pre>

~8
~7
~3
~5
~undefined
~NaN
~Null
~<code>'a + b'</code>
*Ошибка



%Какую из переменных можно вывести на консоль вне блока <code>if()</code>?
<pre><code>
if (true) {
    var a = 3;
    let b = 5;
}
</code></pre>

*a
~b
~a и b
~Ни одну



%Какое максимальное количество вызовов функции <code>calc</code> будет храниться в стеке в результате вызова <code>calc(4)</code>?
<pre><code>
const calc = n => {
	if(n === 1) return 1;
	return n + calc(n-1);
}
</code></pre>

~Нисколько, так как вызовы рекурсивной функции хранятся в куче (hip)
~Данная функция не является рекурсивной, поэтому нисколько
~1
*4
~7
~8
~10


%Можно ли передать функцию в качестве аргумента другой функции?
*Получится функция обратного вызова
~Возникнет ошибка
~Только если функция-аргумент возвращает значение при помощи <code>return</code>
~Функция-аргумент будет проигнорирована
~Функция-аргумент будет преобразована в простой тип


%Сколько функций обратного вызова Вы здесь видите?<br>
<code>function calc(a, ...b){ return b.map(item => a(item));}</code>

~0
~1
*2
~3
~4
~b.length
~item
~Так писать нельзя


%Чем отличается функция-слушатель от обработчика события?
~Слушатель лишь прослушивает событие, а обработчик еще и обрабатывает
~Только синтаксически
~Обработчик события не вызывает "погружения" (делегирования) и "встплытия" событий в отличие от слушателя
~Функция-слушатель позволяет обработать событие только на целевом элементе (target), а обработчик сработает и на родительских элементах
~Слушатель поддерживает функции обратного вызова, а обработчик не поддерживает
*Слушатель может прослушивать одно и то же событие, вызывая несколько callback-функций последовательно, обработчик - только одну


%Отметьте верные способы добавления свойства в литеральный объект <code>const obj = {a: 'свойство1', b: 'свойство2'};</code>:
*<code>obj.c = 'свойство3';</code>
~<code>obj.push({c: 'свойство3'});</code>
*<code>obj["c"] = 'свойство3';</code>
*<code>obj['c'] = 'свойство3';</code>
~Это можно было сделать только при инициализации
~<code>obj = {a: 'свойство1', b: 'свойство2', c: 'свойство3'};</code>
~Объявление через const создало неизменяемый объект


%Отметьте верные способы добавления метода в литеральный объект <code>const obj = {a: 'свойство1', b: 'свойство2'};</code>:
*<code>obj.method = function(){  }; </code>;
~Это можно было сделать только при инициализации
~<code>obj = { method: function(){  } };</code>
~<code>obj.method: function(){  }; </code>;
~Объявление через const создало неизменяемый объект
*<code>obj.method = _ => {  }; </code>;


%Как проверить сущестование свойства объекта, не вызвав ошибок выполнения?
*Обратиться к нему по идентификатору через оператор "." и использовать условный оператор
*Воспользоваться методом keys() объекта Object, а затем перебрать полученный массив
*Использовать метод hasOwnProperty() у проверяемого объекта
~Вызвать функцию eval() с именем свойства в кавычках в качестве аргумента
*Записать свойство так: <code>объект["имяСвойства"]</code>, - и использовать условный оператор


%В каких случаях следует вызывать метод <code>setAttribute()</code> и только его?
~Если требуется изменить ссылку на изображение img, содержащуюся в src
*Если нужно добавить элементу атрибут, отсутствующий в объектной модели
~В случае, если элмемент отсутствовал в html-разметке, но был сгенерирован методом <code>createElement()</code>
~Метод устарел и его вызывать не следует (по стандарту ES6)


%Свойство style:
*Доступно у любого элемента web-страницы
*Содрежит вложенные свойства, соответствующие CSS-стилям
~Названия свойств в объектной модели в точности совпадают с названиями CSS-свойств
~Всегда содержит непустые значения соответствующих CSS-свойств
